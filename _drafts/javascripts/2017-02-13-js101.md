---
layout: post
title:  "JS Basic: EP1. พื้นฐานแบบเน้นๆ"
subtitle: "ปูพื้นฐาน javascripts ใหม่กันเถอะ"
date:   2017-02-13 10:10:00 +0700
categories: javascripts framework
image: /assets/images/thumbnail/js101.png
---

เชื่อว่าหลายๆคนคงเขียน javascripts มากันพอสมควรแล้ว แต่น่าจะมีหลายคนที่อาจจะมองข้ามพื้นฐานเล็กๆน้อยๆไป ซึ่งผมก็เป็นหนึ่งในนั้น แต่หลังจากที่ไปศึกษาพื้นฐานในระดับลึกลงไปแล้ว ผมคิดว่าส่วนนี้สำคัญมากการในทำงาน ซึ่งคาดว่าจะช่วยให้การเขียนโค้ดของเราดีขึ้น เนื่องจากเราจะได้เห็นภาพอะไรบางอย่างที่แตกต่างออกไป ซึ่งเราจะมาเริ่มตั้งแต่การประกาศตัวแปร ไปจนถึงเรื่องใหม่ๆบน ES6 ในระดับละเอียดลงไปอีกระดับ

ก่อนอื่นมารู้คำศัพท์กันก่อน จะได้เข้าใจตรงกันนะฮะ

## คำศัพท์

- EcmaScript (ES)

Ecmascript เป็นมาตรฐานของภาษาจาวาสคริปโดยมีการพัฒนาพื้นฐานมาเรื่อยๆจนถึงปัจจุบัน โดยในปัจจุบันที่รองรับในบราวเซอร์ทั่วไป คือ `ES5` 

และเมื่อปีที่แล้วได้ทำการประกาศมาตรฐานรุ่นใหม่ขึ้นมาชื่อ `ES6` หรือ `ES2015` ซึ่งมีการปรับปรุงและเพิ่มเติมฟีเจอร์หลายๆอย่างซึ่งช่วยให้เราสามารถเขียน javascripts ได้ง่ายขึ้น แล้วก็ยังมีที่มาตรฐานในยุคถัดๆที่ยังร่างกันอยู่ เช่น `ES7` `ES8`

Browser และ Node.js เวอร์ชันใหม่ได้เริ่มพัฒนาให้รองรับ ES6 กันแล้ว แต่เราไม่สามารถใช้กับบราวเซอร์เก่าๆที่ยังใช้กันส่วนมากได้ แต่มีวิธีแก้ครับ

- Transplier

วิธีการแรกคือการแปลงโค้ดที่เราเขียนในรูปแบบของ ES6 ให้เป็นโค้ดในรูปแบบของ ES5 โดยใช้สิ่งที่เรียกว่า Transpiler ซึ่งมีอยู่หลายตัวด้วยกัน เช่น `babel` เป็นต้น


- Polyfill

วิธีการที่ 2 คือการเขียนฟังก์ชันขึ้นมาโดยใช้โค้ดที่ ES5 รองรับ แต่สามารถทำงานแทนฟังก์ชันที่ build-in มากับ ES6 ได้ เช่น

```
Number.isInteger(0);
```

ใช้สำหรับตรวจสอบว่าเป็นค่า int หรือไม่ หากใช้ในบราวเซอร์ที่ไม่รองรับ ES6 ก็สามารถเพิ่ม Polyfill ให้รองรับได้

```
Number.isInteger = Number.isInteger || function(value) {
  return typeof value === 'number' && 
    isFinite(value) && 
    Math.floor(value) === value;
};
```

# Variable

การประกาศตัวแปรใน Javascripts นั้น เป็นการประกาศแบบไม่ระบุ type ของตัวแปร โดยใช้คำสั่งง่ายๆคือ `var`

```
var a = 69;
var b = "hello world";
```

หลายๆคนคงคุ้นชินอยู่แล้ว แต่จริงๆ แล้วตัวแปรบนจาวาสคริปนั้นมี type ของมันเอง ซึ่งแบ่งเป็น 2 ประเภทหลัก คือ

## Primitive Types

หรือตัวแปรดั้งเดิม เป็นตัวแปรประเภทค่าเดียว ได้แก่ `String` `Number` `Boolean` `null` `undefined`
โดยสามารถประกาศตัวแปรได้ง่ายๆ

```
var a = "hello";
var b = 2;
var c = true;
var d = null;
var f = undefined;
```

ซึ่งจะเป็นคุณสมบัติคร่าวๆดังนี้

#### Pass by Value

ตัวแปรจำพวก Primitive Types พวกนี้เป็น pass by value โดยการสร้างตัวแปรใหม่ จะ copy value เดิมแล้วชี้ไปที่ memory ที่ใหม่ เช่น

```
var a = 10;
var b = a;
b += 5;

a 	// 10
b 	// 15
```

#### Immutable

หรือไม่สามารถเปลี่ยนแปลงค่าได้ ทำแบบนี้ไม่ได้นะ ถึงจะไม่ error อะไรก็เถอะ

```
var a = "test"
a[1] = "4"
a 	// "test"
a = "test2"
a 	// "test2"
```

การเปลี่ยนแปลงค่าสามารถทำได้ด้วยการเปลี่ยนค่าผ่านการชี้ references ไปยัง memory ตัวใหม่เท่านั้น โดยผ่านเครื่องหมาย `=` นั่นเอง


## Object Types

หรือตัวแปรที่มีค่าซับซ้อน เช่น `Object` `Array` สามารถประกาศตัวแปรได้ดังนี้

Object => `{}` / Array => `[]`

```
var a = [];		// ประกาศอาเรย์เปล่า
var b = [1,2,3];	// อาเรย์แบบมีค่าตั้งต้น

var c = {};		// ออปเจ็คเปล่า
var d = {		// ออปเจ็คแบบมีค่าตั้งต้น
	x: 2
};
```

ตัวแปรประเภทนี้มีคุณสมบัติดังนี้

#### Shared Value

ตัวแปรใน Javascripts นั้นจะเป็น `Pass by value` ทั้งหมด แต่ในค่าจำพวก Object นั้นตัว Value จะเก็บเป็น References ไปยัง memory ที่เก็บ Object อีกที ดังนั้นการประกาศตัวแปรใหม่ก็จะเป็นคนละตำแหน่งใน memory เช่นเดียวกับ Primitive Types จากนั้นก็จะได้ค่า References ที่ชี้ไปยังที่เก็บ Object อีกที แต่ตัว References นั้นจะเป็นตัวเดียวกันนั่นเอง ค่าของ Object จึงเป็นค่าเดียวกัน

อาจจะมองเป็นภาพง่ายๆแบบนี้

| Variable      | Point to Memory |
| ------------- |---------------|
| a     				| 1 							|
| b     				| 2 							|

| Memory Index  | Value 					|
| ------------- |---------------|
| 1    					| 0001						|
| 2     				|	0001 						|

ค่า Value ชี้มาที่ Object ตัวเดียวกัน

| Object 				| Value 					|
| ------------- |---------------|
| 0001    			| { c: 2 }				|


ผลลัพธ์จึงเป็นการที่ค่านั้นสามารถเปลี่ยนแปลงได้หากทำการเปลี่ยนค่าในตัวแปรอื่นที่ใช้ค่าร่วมกัน

```
var a = [0, 1, 2];
var b = a;
b.push(3)

a // [0, 1, 2, 3]
b // [0, 1, 2, 3]
```

### Object

Object บน Javascript นั้นอยู่ในรูปแบบ `[key]:[value]` โดยสามารถเรียกใช้งานได้ทั้งแบบ key `a['key']` และแบบ property `a.key` โดยข้อดีของแบบ key คือเราสามารถใส่ String แปลกๆได้

```
var a = {
	['b']: 2,
	c: 3
	'd': 4
}

a['c'] 	// 3
a.b 	// 2

a['test-2'] = 4;
a.f = 5
```

และรูปแบบ key ยังสามารถใช้ operator ได้ด้วย ซึ่งจะช่วยให้ง่ายหากเราต้องใช้ key ในรูปแบบของ dynamic key

```
var prefix = "test"
var a = {
	[prefix + "1"]: "a"
}
```

### Array

อาเรย์หรือการเก็บข้อมูลแบบชุด ไม่จำกัดว่าค่านั้นจะเป็นประเภทอะไร โดยเก็บค่าเป็น [index]:[value] โดย index มีค่าเป็น positive integer

```
var a = [1,2,3,"4",true];

a[0] 	// 1
a[3] 	// "4"
a[4] 	// true
```

แต่จริงแล้วก็สามารถใช้อาเรย์ในรูปแบบของ [key]:[value] เหมือนกับ object ได้ เพราะจริงๆแล้วอาเรย์นั้นมีพื้นฐานคล้ายๆกับ object โดยเปรียบเสมือน objecy ที่มี key เป็น index นั้นเอง

```
var a = ["a", "b", "c"];
var b = { 0: "a", 1: "b", 2: "c" };

a[0] // "a"
b[0] // "a"

a["a"] = 3

a // [0: 0, 1: 1, 2: 2, a: 3, length: 3]
```

แต่เราควรหลีกเลี่ยงหรือห้ามใช้งานแบบนี้ไปเลยนะครับ เนื่องจาก array ได้ถูก optimize มาสำหรับใช้เก็บค่าแบบ index อยู่แล้ว จะทำให้เกิดการทำงานที่ผิดพลาดขึ้นได้

#### ตัวอย่าง Build-In Method

```
var a = [1,2,3,4,5];

a.length 		// 5
a.length = 10 		// [1,2,3,4,5,,,,,]
a.push(6) 		// [1,2,3,4,5,6]
a.pop() 		// [1,2,3,4]
a.shift() 		// [2,3,4,5]
```

### Other

และยังมี Type อื่นๆ เช่น `Function` `Date` `Error` `RegExp`

## ES6

การประกาศตัวแปรบน ES6 นั้น มีฟังก์ชันที่เพิ่มขึ้นมา โดยมีตัวเลือกให้สองแบบคือ `let` และ `const`

### Let

`let` คือสิ่งที่มาแทน `var` นั่นเอง โดยจะมีคุณสมบัติพิเศษเรื่อง scope ซึ่งจะอธิบายในบทถัดไป

### Const

คือตัวแปรที่ไม่สามารถเปลี่ยนแปลงค่าได้ ซึ่งเมื่อทำการ assign ค่าให้แล้ว จะไม่สามารถ assign ค่าใหม่ได้อีก ซึ่งหากเราพยายามทำการเปลี่ยนค่า จะเกิด Error แสดงทันที

```
const a = 10;
a = 2		// TypeError
```

__ข้อควรระวัง__ หากใช้ const กับ `Object` และ `Array` เรายังสามารถเปลี่ยนแปลงค่าได้ แต่ไม่สามารถชี้ไปที่ค่าใหม่ได้ เนื่องจากค่า references ของตัวแปรไม่ได้เปลี่ยน แต่เป็นการเปลี่ยนค่าที่ object นั่นเอง

```
const b = [1,2,3];
b.push(4);

b // [1,2,3,4]

b = [4,5,6];  // TypeError
```

### Hoist

Variable ใน js นั้น จะมีด้วยกัน 2 step คือการ `Declare` หรือการประกาศตัวแปร และ `Assign` หรือการชี้ตัวแปรไปยังค่านั้น เช่น

```
var a = 10;
```

แต่ในการรัน แยกออกเป็น 2 step

```
var a;		// Declare
a = 10;		// Assign
```

เราจึงเห็นได้ว่า บางทีเราสามารถเรียกใช้ตัวแปรนั้นได้ก่อนการประกาศตัวแปร

```
a 	// undefined
var a = 10;
a 	// 10
```

เนื่องจากจริงๆแล้วตัว JS Engine ได้ทำการยกการ Declare ตัวแปรทั้งหมดใน Scope นั้นขึ้นไปไว้บนสุดของ Scope

```
var a;
a 	// undefined
a = 10;
a 	// 10
```

## Type Casting

การเปลี่ยน type ของค่าใน javascripts นั้นมีอยู่ 2 รูปแบบ

#### Explicit Cast

หรือการเปลี่ยนแปลงค่าจากคำสั่งโปรแกรม เช่น แปลงค่าจาก String เป็น Number โดยใช้คำสั่ง `parseInt`

```
var a = parseInt("2");		// 2 (Number)
a.toString();			// "2" (String)
```

#### Implicit Cast

เป็นการเปลี่ยนแปลงค่าที่เกิดจากตัว JS Engine ทำการเปลี่ยนให้เพื่อให้ทำงานได้ ซึ่งจะเกิดขึ้นภายในการรันโปรแกรม เช่น การใช้ operator กับค่าที่เป็นคนละ Type กัน

```
var a = 2 + "2"		// Implicit Cast 2 >> "2"
var b = true + 1	// Implicit Cast true >> 1

a 	// "22"
b 	// 2
```

ซึ่งทั้ง 2 แบบนี้มีวิธีและผลลัพธ์ที่เหมือนกัน โดยเราสามารถดูได้จากเว็บนี้ว่า ค่าใน type หนึ่งนั้น หาก cast ไป type อื่นจะสามารถเป็นอะไรได้บ้าง หรือเมื่อเปรียบเทียบแล้วจะเท่ากันหรือไม่ [JavaScript Equality Table](https://dorey.github.io/JavaScript-Equality-Table/)

![JavaScript Equality Table](/assets/images/posts/js101/js-equal-table.png)

ส่วน Priority ในการ Cast Type ใน operation ต่างๆนั้น ในแต่ละ Type จะมี Priority ต่างกัน และไล่คำนวนไปทีละ operator ตามวงเล็บครับ โดยในรายการนี้เรียงจาก Priority มากสุดไปน้อยสุด

```
String
Number
Boolean
null
undefined
```

หากมีการเปลี่ยนเทียบหรือกระทำค่าระหว่าง String กับ Number ตัว Number Priority ต่ำกว่าก็จะถูก cast เป็น String

#### Mini Quiz

```
true + 2 + (2 + 2 + "2" + ( true + null + 1 ) + false) = ?
```

ได้เท่าไหร่กันนะ ...... คำตอบคือ "3422false"

## Object Wrapper

ในการประกาศตัวแปรใน javascripts นั้น เราอาจจะเห็นว่าเราสามารถ assign ค่าที่เป็น type อะไรก็ได้เข้าไปในตัวแปรนั้นได้เลย แต่จริงๆแล้วยังมีวิธีการประกาศตัวแปรอีกแบบ คือ การสร้าง object ของ type นั้นขึ้นมาใหม่ โดยใช้คำสั่ง `new object` เช่น

```
var a = new String("Hello World");
var b = new Number(2);

a 	// String { .... }
b 	// Number { .... }
```

ซึ่งจะเป็นการประกาศตัวแปรแบบระบุ type โดยจะมี object ของ type นั้นครอบอยู่ด้วย โดย Object พวกนี้ก็จะมี Built-in Method ให้เราเรียกใช้ตามค่านั้นๆ เช่น `.toString()` `.toUppercase()` เป็นต้น

ย้อนกลับมาดูการประกาศตัวแปรแบบไม่ระบุ type

```
var a = "hello world";

a 				// "hello world"
a.toUpperCase() 		// "HELLO WORLD"
```

แต่เดี๋ยวก่อน ทั้งที่เราไม่ได้ประกาศตัวแปรเป็น object type นั้น แล้วทำไมเราถึงยังสามารถใช้ build-in method ได้อยู่ละ

นั่นก็เพราะว่าจริงๆแล้วตัวแปรที่ประกาศใน javascripts นั้น จะมีส่วนของ `Object Wrapper` หรือการครอบ Object Type ของตัวแปรนั้นๆให้ หากค่านั้นเป็น `String` ก็จะมี `String` object ครอบอยู่ และเราก็สามารถเรียกใช้งาน build-in method ได้นั้นเอง

## Operator

### Abstract Equal

เราใช้เครื่องหมาย `==` และ `!=` ในการเปรียบเทียบค่าว่าสองค่าทั้งสองฝั่ง

```
2 == 2		// true
3 != 2		// true
8 == 2		// false
```

และหาก Type ทั้งสองฝั่งไม่เหมือนกัน ตัว javascripts engine จะทำการ cast ค่า หรือเปลี่ยนแปลงค่าให้เหมือนกันและทำการเปรียบเทียบ ดังนั้นเราจะเห็นได้ว่าบางครั้ง คนละ Type กัน แต่ผลลัพธ์สามารถออกเป็น `true` ได้ เช่น

```
2 == "2"	// true
```

เมื่อทำการรันเปรียบเทียบ javascripts engine จะมองเห็นว่า type ของทั้งสองฝั่งไม่เหมือนกัน ฝั่งนึงเป็น `Number` และอีกฝงั่เป็น `String` ก็จะทำการ cast ตาม prioity ตามหัวข้อข้างบน โดย cast 2 เป็น "2" การรันจึงเปลี่ยนเป็น `"2" == "2"` จึงได้ผลลัพธ์เป็น true นั่นเอง


### Strict Equal

ใช้เครื่องหมาย `===` และ `!==` ในการเปรียบเทียบ ซึ่งในกรณีนี้ ตัว Javascripts Engine จะไม่ทำการ Cast Type แล้ว หากคนละ Type ก็จะไม่เท่ากันไปเลย

```
2 === "2"		// false
2 === 2			// true
```

> จะเห็นได้ว่าเราควรใช้การเปรียบเทียบแบบ Strict Equal มากกว่า เพื่อป้องกันความผิดพลาดของโปรแกรมที่เกิดจากการแปลงค่าของตัว Javascripts Engine แต่ในบางกรณีการเปรียบเทียบแบบ Abstract ก็ช่วยให้เราเขียนโค้ดได้สวยงามกว่า ดังนั้นต้องเลือกใช้ให้ดีๆ

### Other

ในส่วนของการเปรียบเทียบและกระทำการกับค่าและตัวแปรแบบอื่นๆนั้น จะเป็นรูปแบบของ Abtract เท่านั้น ไม่มีแบบ strict mode ดังนั้นเมื่อใช้งานให้ระวังการเกิด Implicit Type Casting กันด้วยนะครับ

`>=` `<=` `>` `<` `+` `-` `*` `/` `%`

```
2 <= "3"		// true
2 > true		// true
false + 1		// 1
true + "2"	// "true2"
```

และอื่นๆ สามารถดู list operator ทั้งหมดได้ที่นี่ >> [MDN: Expressions and operators](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Expressions_and_Operators)

## Function

ฟังก์ชัน ใน javascripts สามารถประกาศได้ง่ายๆโดยใช้คำสั่ง `function` โดยสามารถประกาศได้หลายแบบ

- Named Function

```
function add(x,y) {
	return x + y;
}

var a = add(10,20); // 30
```

- Anonymous Function

หรือฟังก์ชันที่ไม่มีชี่อ เราสามารถใช้ตัวแปรชี้ไปที่ฟังก์ชันนั้น และสามารถนำไปเรียกใช้ได้ หรือใช้ในการ pass เข้าไปเป็นตัวแปรในฟังก์ชันอื่นๆ

```
var add = function(x,y) {
	return x + y;
}

var a = add(10,20); // 30
```

```
setTimeout(function() {			// <= Anonymous Function
	var a = 1;
}, 100)
```

- IIFE Function (Immediately Invoked Function Expressions)

หรือการประกาศฟังก์ชันที่รันทันที

```
(function echo() {
	console.log("Hello")
})();

// Hello
```

### New Operator

คำสั่ง `new` ใน Javascripts ให้สำหรับสร้าง object ใหม่ซึ่ง references กับตัว function นั้นโดยตัวแปรที่สร้างจาก new จะทำการ inheriting function เดิม คือสามารถเรียกใช้ method, property ของฟังก์ชันเดิมได้ แต่เป็น scope คนละตัวกัน ซึ่งเรื่อง scope จะอธิบายต่อในบทถัดไปนะครับ

```
var Person = function(name) {
	this.name = name

	this.getName = function() {
		return this.name;
	}
}

var john = new Person("john");
var sara = new Person("sara");

john.getName();		// "john"
sara.getName();		// "sara"
```

## Strict Mode

การรัน javascript นั้นมีด้วยกัน 2 โหมดคือ ธรรมดา และ strict mode ซึ่ง ข้อแตกต่างระหว่างสองอย่างนี้คือ

- Strict Mode ช่วยให้โค้ด Error ง่ายขึ้น

การออกแบบ javascript นั้น ในยุคก่อนหน้านี้ไม่ได้ให้ความสำคัญกับ error อะไรมาก ดังนั้นในการรันการทำงานหลายๆอย่างนั้น อาจจะไม่ี error ออกมา ทั้งๆที่โดย common sense แล้วมันควรจะ error ( engine ไม่ได้ออกแบบมาให้แสดง error ตรงส่วนนั้นในโหมดธรรมดา ) แต่พอรันด้วย strict mode แล้ว error หลายๆจะถูกปรับให้แสดงผลออกมา เพื่อช่วยให้เราเขียนโค้ดได้ง่ายและโปรแกรมรันได้ถูกต้องมากขึ้น ( ที่ไม่สามารถปรับให้โหมดธรรมดารันแล้วแสดงผล error ขึ้นมาได้ เพราะต้องการให้ compatible กับเวอร์ชันก่อนๆ ) ยกตัวอย่างเช่น

การไม่ประกาศ var ก่อนหน้าการประกาศตัวแปร หากเราในโหมดธรรมดาก็จะรันได้ปกติ (ทำไมมันไม่ error ฟร่ะ ยังไม่ได้ประกาศซักหน่อย)

```
a = 2
a 	// 2
```

หากรันบน strict mode ด้วยการคำสั่ง `use strict` ด้านบน ก็จะขึ้น error ด้วยประกาศฉะนี้แล

```
'use strict';

a = 2		// ReferenceError a not defined
```

ก็จะช่วยให้เราหลีกเลี่ยงความผิดพลาดที่อาจจะเกิดจากการโค้ดไม่ระวังได้ง่ายขึ้น

- Strict Mode ช่วยให้โค้ดบางส่วนรันได้เร็วขึ้น

เนื่องจาก Engine หลายๆตัวได้ทำการ Optimize การรัน JS บน Strict Mode ไว้แล้ว ช่วยให้สามารถรันโค้ดบางอย่างได้เร็วกว่าโหมดธรรมดา


## References

- [You Don't Know JS: Up & Going > Chapter 2: Into JavaScript](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md)
- [JavaScript Equality Table](https://dorey.github.io/JavaScript-Equality-Table/)
- [MDN: Strict Mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
- [MDN: Expressions and operators](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Expressions_and_Operators)