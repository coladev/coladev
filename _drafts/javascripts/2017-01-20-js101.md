---
layout: post
title:  "JS Basic: EP1. ปูพื้นฐานแบบเน้นๆ"
subtitle: "ปูพื้นฐาน javascripts กันใหม่กันเถอะ"
date:   2017-01-16 02:15:41 +0700
categories: javascripts framework
image: /assets/images/thumbnail/js101.png
---

เชื่อว่าหลายๆคนคงเขียน javascripts มากันพอสมควรแล้ว แต่น่าจะมีหลายคนที่อาจจะมองข้ามพื้นฐานเล็กๆน้อยๆไป ซึ่งผมก็เป็นหนึ่งในนั้น แต่หลังจากที่ไปศึกษาพื้นฐานในระดับลึกลงไปแล้ว ผมคิดว่าส่วนนี้สำคัญมากการในทำงาน ซึ่งคาดว่าจะช่วยให้การเขียนโค้ดของเราดีขึ้น เนื่องจากเราจะได้เห็นภาพอะไรบางอย่างที่แตกต่างออกไป ซึ่งเราจะมาเริ่มตั้งแต่การประกาศตัวแปร ไปจนถึงเรื่องใหม่ๆบน ES6 ในระดับละเอียดลงไปอีกระดับ

ก่อนอื่นมารู้คำศัพท์กันก่อน จะได้เข้าใจตรงกันนะฮะ

## คำศัพท์

- EcmaScript (ES)

Ecmascript เป็นมาตรฐานของภาษาจาวาสคริปโดยมีการพัฒนาพื้นฐานมาเรื่อยๆจนถึงปัจจุบัน โดยในปัจจุบันที่รองรับในบราวเซอร์ทั่วไป คือ `ES5` 

และเมื่อปีที่แล้วได่ทำการประกาศมาตรฐานรุ่นใหม่ขึ้นมาชื่อ `ES6` หรือ `ES2015` ซึ่งมีการปรับปรุงและเพิ่มเติมฟีเจอร์หลายๆอย่างซึ่งช่วยให้เราสามารถเขียน javascript ได้ง่ายขึ้น

และยังมีที่มาตรฐานในยุคถัดๆที่ยังร่างกันอยู่ เช่น `ES7` `ES8`

Browser และ Node.js เวอร์ชันใหม่ได้เริ่มทำการรองรับ ES6 กันแล้ว แต่เราไม่สามารถใช้กับบราวเซอร์เก่าๆที่ยังใช้กันส่วนมากได้ แต่มีวิธีแก้ครับ

- Transplier

วิธีการแรกคือการแปลงโค้ดที่เราเขียนในรูปบบของ ES6 ให้เป็นโค้ดในรูปแบบของ ES5 โดยใช้สิ่งที่เรียกว่า Transpiler ซึ่งมีอยู่หลายตัวด้วยกัน เช่น `babel` เป็นต้น


- Polyfill

วิธีการที่ 2 คือการเขียนฟังก์ชันขึ้นมาโดยใช้โค้ดที่ ES5 รองรับ แต่สามารถทำงานแทนฟังก์ชันที่ buildin มากับ ES6 ได้ เช่น

```
Number.isInteger(0);
```

ใช้สำหรับตรวจสอบว่าเป็นค่า int หรือไม่ หากใช้ในบราวเซอร์ที่ไม่รองรับ ES6 ก็สามารถเพิ่ม Polyfill ให้รองรับได้

```
Number.isInteger = Number.isInteger || function(value) {
  return typeof value === 'number' && 
    isFinite(value) && 
    Math.floor(value) === value;
};
```

# Variable

การประกาศตัวแปรใน Javascripts นั้น เป็นการประกาศแบบไม่ระบุ Type ของตัวแปร โดยใช้คำสั่งง่ายๆคือ `var`

```
var a = 69;
var b = "hello world";
```

หลายๆคนคงคุ้นชินอยู่แล้ว แต่จริงๆแล้วตัวแปรบนจาวาสคริปนั้นมี Type ของมันเองซึ่งแบ่งเป็น 2 ประเภทหลัก คือ

## Primitive Types

หรือตัวแปรดั้งเดิม (แปลกูเกิลมา 55) เป็นตัวแปรประเภทค่าเดียว เช่น `String` `Number` `Boolean` `null` `undefined`
โดยสามารถประกาศตัวแปรได้ง่ายๆ

```
var a = "hello";
var b = 2;
var c = true;
var d = null;
var f = undefined;
```

ซึ่งจะเป็นคุณสมบัติคร่าวๆดังนี้

- Pass by Value

ตัวแปรจำพวก Primitive Types พวกนี้เป็น pass by value โดยการสร้างตัวแปรใหม่ จะ copy value เดิมแล้วชี้ไปที่ memory ที่ใหม่ เช่น

```
var a = 10;
var b = a;
b += 5;

a 	// 10
b 	// 15
```

- Immutable

หรือไม่สามารถเปลี่ยนแปลงค่าได้ ทำแบบนี้ไม่ได้นะ ถึงจะไม่ error อะไรก็เถอะ

```
var a = "test"
a[1] = "4"

a 	// "test"
```

การเปลี่ยนแปลงค่าสามารถทำได้ด้วยการเปลี่ยนค่าผ่าน operator เท่านั้น


## Object Types

หรือตัวแปรที่มีค่าซับซ้อน เช่น `Object` `Array` สามารถประกาศตัวแปรได้ดังนี้

Object => `{}` / Array => `[]`

```
var a = [];		// ประกาศอาเรย์เปล่า
var b = [1,2,3];	// อาเรย์แบบมีค่าตั้งต้น

var c = {};		// ออปเจ็คเปล่า
var d = {		// ออปเจ็คแบบมีค่าตั้งต้น
	x: 2
};
```

ตัวแปรประเภทนี้มีคุณสมบัติดังนี้

- Shared Value

หรือจะบอกว่าเป็น pass by copy of reference ก็ได้ โดยจริงๆแล้วค่าที่เก็บไว้นั้นเป็นค่าเดียวกัน แต่ references ที่ point ไปที่ค่านั้นเป็นคนละตัวกัน (แต่ชี้ที่เดียวกันนั้นแหละ) ดังนั้นเมื่อเราเปลี่ยนค่าในตัวแปรหนึ่ง แต่อีกค่าก็จะเปลี่ยนตาม ( แต่ไม่ใช่ pass by reference นะ คนละแบบกัน เดี๋ยวอธิบายตอนหลัง)

```
var a = [0, 1, 2];
var b = a;
b.push(3)

a // [0, 1, 2, 3]
b // [0, 1, 2, 3]
```

### Array

### Object

## ES6

การประกาศตัวแปรบน ES6 นั้น มีฟังก์ชันที่เพิ่มขึ้นมา โดยมีตัวเลือกให้สองแบบคือ `let` `const`

### Let

`let` คือสิ่งที่มาแทน `var` นั่นเอง โดยจะมีคุณสมบัติพิเศษเรื่อง scope ซึ่งจะอธิบายในบทถัดไป

### Const

หรือคือตัวแปรที่ไม่สามารถเปลี่ยนแปลงค่าได้ ซึ่งเมื่อทำการ assign ค่าให้แล้ว จะไม่สามารถแก้ไข หรือ assign ค่าใหม่ได้ 
(พูดแบบละเอียดคือ ไม่สามารถเปลี่ยน pointer references ได้แล้ว) ซึ่งหากเราพยายามทำการเปลี่ยนค่า จะเกิด Error แสดงทันที

```
const a = 10;
a = 2		// TypeError
```

_ข้อควรระวัง_ หากใช้ const กับ Object Type เรายังสามารถเปลี่ยนแปลงค่าได้อยู่ แต่ไม่สามารถชี้ไปที่ค่าใหม่ได้

```
const b = [1,2,3];
b.push(4);

b // [1,2,3,4]

b = [4,5,6];  // TypeError
```

### Hoist

Variable ใน js นั้น จะมีด้วยกัน 2 step คือการ `Declare` หรือการประกาศตัวแปร และ `Assign` หรือการชี้ตัวแปรไปยังค่านั้น เช่น

```
var a = 10;
```

แต่ในการรัน แยกออกเป็น 2 step

```
var a;		// Declare
a = 10;		// Assign
```

เราจึงเห็นได้ว่า บางทีเราสามารถเรียกใช้ตัวแปรนั้นได้ก่อนการประกาศตัวแปร

```
a 	// undefined
var a = 10;
a 	// 10
```

เนื่องจากจริงๆแล้วตัว JS Engine ได้ทำการยกการ Declare ตัวแปรทั้งหมดใน Scope นั้นขึ้นไปไว้บนสุดของ Scope

```
var a;
a 	// undefined
a = 10;
a 	// 10
```

## Type Casting

การเปลี่ยน type ของค่าในจาวาคริปนั้นมี 2 รูปแบบ

- Explicit Cast

หรือการเปลี่ยนแปลงค่าจากคำสั่งโปรแกรม เช่น แปลงค่าจาก String เป็น Number โดยใช้คำสั่ง `parseInt`

```
var a = parseInt("2");		// 2 (Number)
a.toString();			// "2" (String)
```

- Implicit Cast

เป็นการเปลี่ยนแปลงค่าที่เกิดจากตัว JS Engine ทำการเปลี่ยนให้เพื่อให้ทำงานได้ ซึ่งจะเกิดขึ้นภายในการรัน เช่น การใช้ operator กับค่าที่คนละ type กัน

```
var a = 2 + "2"		// Implicit Cast 2 >> "2"
var b = true + 1	// Implicit Cast true >> 1

a 	// "22"
b 	// 2
```

ซึ่งทั้ง 2 แบบนี้มีวิธีและผลลัพธ์ที่เหมือนกัน

## Object Wrapper

## Operator

### Abstract Equal

ใช้เครื่องหมาย `==` และ `!=` เป็นการเปรียบเทียบค่าว่าเท่ากันหรือไม่เท่ากันหรือไม่

```
2 == 2		// true
3 != 2		// true
8 == 2		// false
```

โดยการเปรียบเทียบแบบี้ จาวาสคริป Engine จะทำการเปรียบเทียบค่าทั้งสองฝั่ง
และหาก Type ทั้งสองฝั่งไม่เหมือนกัน ตัว engine จะทำการ cast ค่า หรือเปลี่ยนแปลงค่าให้เหมือนกันและทำการเปรียบเทียบ
ดังนั้นเราจะเห็นได้ว่าบางครั้ง คนละ Type กัน แต่ผลลัพธ์สามารถออกเป็น `true` ได้ เช่น

```
2 == "2"	// true
```

เมื่อทำการรัน JS Engine เมื่อเห็นว่า type ของทั้งสองฝั่งไม่เหมือนกัน ฝั่งนึงเป็น `Number` และอีกฝงั่เป็น `String` ก็จะทำการ cast ฝั่ง RHS (Right Hand-Side) หรือฝั่งขวา ให้เป็น type เดียวกันกับฝั่งซ้าย ซึ่งก็จะกลายเป็น `2 == 2` ผลลัพธ์จึงออกมาเป็น `true` นั้นเอง 

### Strict Equal

ใช้เครื่องหมาย `===` และ `!==` ในการเปรียบเทียบ ซึ่งในกรณีนี้ ตัว JS Engine จะไม่ทำการ Cast Type แล้ว หากคนละ Type ก็จะไม่เท่ากันไปเลย

```
2 === "2"		// false
2 === 2			// true
```

> จะเห็นได้ว่าเราควรใช้การเปรียบเทียบแบบ Strict Equal มากกว่า เพื่อป้องกันความผิดพลาดของโปรแกรมที่เกิดจากการแปลงค่าของตัว JS Engine แต่ในบางกรณีการเปรียบเทียบแบบ Abstract ก็ช่วยให้เราเขียนโค้ดได้สวยงามกว่า ดังนั้นต้องเลือกใช้ให้ดีๆ

### Other

ในส่วนของการเปรียบเทียบและกระทำการกับค่าและตัวแปรอื่นๆนั้น จะเป็นแบบ Abtract เท่านั้น ดังนั้นเมื่อใช้งานให้ระวังการเกิด Implicit Type Cast กันด้วยนะครับ

`>=` `<=` `>` `<` `+` `-` `*` `/` `%`

และอื่นๆ สามารถดู list operator ทั้งหมดได้ที่นี่ >>


## Function

ฟังก์ชัน ในจาวาสคริปสามารถประกาศได้ง่ายๆโดยใช้คำสั่ง `function` โดยสามารถประกาศได้หลายแบบ

- Named Function

```
function add(x,y) {
	return x + y;
}

var a = add(10,20); // 30
```

- Anonymous Function

หรือฟังก์ชันที่ไม่มีชี่อ เราสามารถใช้ตัวแปรชี้ไปที่ฟังก์ชันนั้น และสามารถนำไปเรียกใช้ได้

```
var add = function(x,y) {
	return x + y;
}

var a = add(10,20); // 30
```

- IIFE Function (Immediately Invoked Function Expressions)

หรือการประกาศฟังก์ชันที่รันทันที

```
(function echo() {
	console.log("Hello")
})();

// Hello
```

## Strict Mode